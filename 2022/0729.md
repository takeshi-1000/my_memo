## スタックについて深掘り（メモリ）

### スタックとは

- データ構造の一種
- 特徴として、あるデータを格納できる箱みたいなものがあった時に、先に箱に詰めたデータよりも後に詰めたデータの方が早く除去されるといった構造を持つようなもののこと
- 調理場に重ねられた多くの皿に例えられることがある。皿が多く重なっていると、先に下に重ねた皿に比べて上に重ねられた皿を使うので

### スタックメモリの話

- 上述のスタックというデータ構造を、条件次第でメモリ上でも実現できる領域がある。それをスタックメモリとか、スタック領域とか、ヒープと退避して単にスタックと呼ばれることがあったり色々
- メモリは、限られたリソースなのでメモリを有効活用するためにも、必要なタイミングでメモリを使って、必要なら無くなったタイミングで除却されると良い。それを上述のスタック構造を持つメモリの領域内で自動で実現してくれるので嬉しいよねという話
- スタックは関数(ルーチン)内のローカル変数や関数の引数のような、一時的にメモリにあってすぐ無くなってほしいようなものに使われる。

### 実行時の仮想メモリアドレス空間の一般的な概念図

<img width="200" alt="スクリーンショット 2022-07-29 5 56 41" src="https://user-images.githubusercontent.com/16571394/181636052-f0453e58-f82f-4202-be6d-7d46e8bf6664.png">

https://kataware.hatenablog.jp/entry/2017/12/02/224444 にある下記添付の方がわかりやすいかな

<img width="200" alt="スクリーンショット 2022-07-29 6 21 41" src="https://user-images.githubusercontent.com/16571394/181639894-62881577-40f5-4763-a37c-3e5f04ae2389.png">


- ある実行バイナリを実行している際のあるプロセスの仮想メモリアドレス空間のイメージ図
- 機械語（関数の実行するコード）そのものも、メモリアドレス空間に展開された状態でその関数のポインタをipに指定して、インクリメントさせるような形で関数内部のアセンブリを実行している（レジスタの話とかしてないので本当にざっくり）
- 静的変数（多分機械語もそう）は、プロセスが終了するまで残り続ける https://github.com/takeshi-1000/my_memo/blob/main/2022/0726.md も参考
- 対してヒープ領域、スタック領域はどちらも動的にメモリに展開される際に使われる領域 https://github.com/takeshi-1000/my_memo/blob/main/2022/0726.md も参考
- ヒープ領域は、アプリケーションレベル（コンパイル前に渡すソースコードレベル）での制御をすることで動的に確保したり、解放したりすることが可能（mallocやfree）
- スタック領域は、アプリケーションレベルでの制御は無理。仮想メモリアドレスのスタックを制御するスタックポインタやベースポインタの値を格納する用のレジスタが用意されており、そのレジスタを機械語命令で制御して、確保や解放を行う。
（機械語命令自体はコンパイラが出力するので、そういった意味ではコンパイラのコードでスタック領域を制御していると言えそう？
あああ

ああ

### テストプログラムを用いたstackのメモリ展開イメージ, 実行イメージ

#### 1. 下記のファイルを準備

```
#include<stdio.h>

int square(int a, int b){
 int num = a * b;
 printf("%d\n", num);
}

int main(void){
        int a = 5;
        int b = 4;
        square(5, 4);
        return 0;
}
```

#### 2. デバッガ(gdb)を使用して、break point にmainとsquareにおいて実行

(小ネタ)

b main で、0x67f, b square で、0x64e, にそれぞれbreakpointを設定してくれたようだが、逆アセンブルした内容見るとどちらもスタック領域確保前のアセンブリの位置で止まる感じ

![スクリーンショット 2022-07-30 5 08 01](https://user-images.githubusercontent.com/16571394/181836165-2166616e-ef18-4d93-a581-2013f1278ad2.png)


#### 3. mainで止まった際に確認

わかること

- ベースポインタ(RBP)、スタックポインタ(RSP)のアドレスは、0x7fffffffddd0である
- スタックは8byteで区切られているっぽい？

![スクリーンショット 2022-07-29 6 38 22](https://user-images.githubusercontent.com/16571394/181835183-e44bcf20-5c8a-4f17-ac29-b8faa0a4ab28.png)

#### 4. sub rsp, 0x10 を実行

![スクリーンショット 2022-07-30 5 13 49](https://user-images.githubusercontent.com/16571394/181836598-fe5d7def-8ceb-4732-9473-00aba04b2d11.png)


わかること

- stackのアドレスが-16され、上部(低位アドレスの方)に拡張された(RBPは変わらず、RSPは0x7fffffffddc0)
- RIPは0x683を指し、次の命令のアドレスを指していそう（逆アセンブルした結果と一致する）


#### 5. mov DWORD PTR [rbp-0x8], 0x5 を実行

![スクリーンショット 2022-07-30 5 23 39](https://user-images.githubusercontent.com/16571394/181837934-d18ab643-9a77-465b-8c37-6a5eb06f573d.png)

わかること

- stackを見ると、bpから0x-8されたところに、0x5が格納されてそう
・0008| 0x7fffffffddc8 --> 0x5 の箇所
・stak領域の大きさに変化はなし
- RIPは0x68aを指し、次の命令のアドレスを指していそう（逆アセンブルした結果と一致する

#### 6. mov DWORD PTR [rbp-0x4], 0x4 を実行

![スクリーンショット 2022-07-30 5 43 01](https://user-images.githubusercontent.com/16571394/181840296-55d440c9-c1b2-4fcc-88cf-da269c805d58.png)

わかること

- stack上では0x4の格納が確認できない。gdbの表示では8byte刻みでしか表示されてないので、その辺りを変更する方法を探す必要がありそう
・stak領域の大きさに変化はなし
- RIPは0x691を指し、次の命令のアドレスを指していそう（逆アセンブルした結果と一致する
